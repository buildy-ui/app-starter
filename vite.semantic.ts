// vite.semantic.ts
import fs from "node:fs/promises";
import path from "node:path";

export default function semanticPlugin() {
  let root = process.cwd();
  let lastWritten = "";
  let debounceTimer: NodeJS.Timeout | null = null;
  return {
    name: "semantic-provider",
    apply: "serve",
    configResolved(c: any) {
      root = c.root;
    },
    configureServer(server: any) {
      server.middlewares.use("/__semantic", async (req: any, res: any, next: any) => {
        if (req.method !== "POST") return next();
        const chunks: Buffer[] = [];
        req.on("data", (c: Buffer) => chunks.push(c));
        req.on("end", async () => {
          try {
            const body = JSON.parse(Buffer.concat(chunks).toString());
            const map = body.map as Record<string, string[]>;
            const lines: string[] = [];
            lines.push("/* generated by semantic provider */");
            lines.push("@layer components {");
            for (const key of Object.keys(map).sort()) {
              const unique = Array.from(new Set(map[key])).sort();
              if (unique.length === 0) continue;
              lines.push(`  .${key} { @apply ${unique.join(" ")}; }`);
            }
            lines.push("}");
            const out = path.join(root, "src", "semantic.css");
            const nextContent = lines.join("\n");
            if (nextContent !== lastWritten) {
              lastWritten = nextContent;
              if (debounceTimer) clearTimeout(debounceTimer);
              debounceTimer = setTimeout(async () => {
                await fs.writeFile(out, nextContent, "utf8");
                // No manual reload. Vite will pick up file change and apply CSS HMR.
              }, 400);
            }
            res.statusCode = 200;
            res.end("ok");
          } catch (e) {
            res.statusCode = 500;
            res.end("error");
          }
        });
      });
    },
  };
}